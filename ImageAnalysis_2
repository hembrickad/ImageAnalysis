import config as cfg
import ImageAnalysis as p1
import numpy as np
import collections
import pandas as pd
from PIL import Image
from random import randint     
import matplotlib.pyplot as plt
from time import perf_counter
# Niblack
def eDist(x, y):
    return np.sqrt(np.sum((x-y)**2))

class KMeans():
    def __init__(self, K=5, max_iters=100, plot=False):
        self.K = K
        self.max_iters = max_iters
        self.plot = plot

        self.clusters = [[] for _ in range(self.K)]
        self.centroids = []

    def pred(self, x):
        self.x = x
        self.nSamples, self.nFeatures = x.shape[0], x.shape[1]

        sampleIDs = np.random.choice(self.nSamples, self.K, replace=False)
        self.centroids = [self.x[id] for id in sampleIDs]

        for _ in range(self.max_iters):
            self.clusters = self.create(self.centroids)
            if self.plot:
                self.plot()
            
            centroids_old = self.centroids
            self.centroids = self.getCent(self.clusters)

            if self.converged(centroids_old, self.centroids):
                break

            if self.plot:
                self.plot()

            return self.getLClusters(self.clusters)

    def getLClusters(self, clusters):
        l = np.empty(self.nSamples)

        for clusterID, cluster in enumerate(clusters):
            for sampleID in cluster:
                l[sampleID] = clusterID
        return labels

    def create(self, centroids):
        clusters = [[] for _ in range(self.K)]
        for id, sample in enumerate(self.x):
            centroidID = self.closest(sample,centroids)
            clusters[centroidID].append(id)
        return clusters

    def getCent(self, clusters):
        centroids = np.zeros((self.K, self.nFeatures))
        for clusterID, cluster in enumerate(clusters):
            clusterMean = np.mean(self.x[cluster], axis=0)
            centroids[clusterID] = clusterMean
        return centroids

    def closest(self,sample,centroids):
        dist = [eDist(sample, p) for p in centroids]
        closestInd = np.argmin(dist)
        return closestInd
    
    def converged(self, oldCentroids, centroids):
        dist = [eDist(oldCentroids[i], centroids[i])for i in range(self.K)]
        s = sum(dist)
        return s ==0

    def plot(self):
        fig, ax = plt.subplots(figsize = (12,8))

        for i, index in enumerate(self.clusters):
            point = self.x[index].T
            ax.scatter(*point)

        for point in self.centroids:
            ax.scatter(*point, marker = "X", color = "black", linewidth = 3)
        plt.show()

    def cent(self):
        return self.centroids


def binary_c(array, r = 120, g = 100, b = 150):
    array = np.array(array)
    for x in array:
        for n in x:
            if n[0] >=r:
                n[0] = 255
            else:
                n[0] = 0
            if n[1] >=g:
                n[1] = 255
            else:
                n[1] = 0
            if n[2] >=b:
                n[2] = 255
            else:
                n[2] = 0
    return array

#def Laplacian(array, filter = [[ 0 1 0],[ 1,-4,1],[0,1,0]]):




#Erosion--Complete
def Erosion(array, median_filter = [[0, 1, 0],[1, 1, 1],[0, 1, 0]]):

    array = p1.binary(array)

    nArray = array.copy()
    image_width, image_height = array.shape[1], array.shape[0]
    

    for y in range(array.shape[0]):
        for x in range(array.shape[1]):
            # Get Image Filter Pixels
            filter_mid = len(median_filter)//2

            # Skip Border Pixels
            if x-filter_mid < 0 or x+filter_mid > image_width: 
                continue
            if y-filter_mid < 0 or y+filter_mid > image_height: 
                continue
            filter_pixels = array[y-filter_mid:y+filter_mid+1,x-filter_mid:x+filter_mid+1]

            # Apply Median Spatial Filter Over Greyscale Image
            # Store First Element (Pixel Value) In Fitler Pixel Row, Since
            #   They're All The Same Value (Greyscale Image)
            pixels = []

            for filter_x, rgb_pixel_values in enumerate(filter_pixels):
                for filter_y, rgb_values in enumerate(rgb_pixel_values):
                    pixel_weight = median_filter[filter_y][filter_x]
                    pixel_value  = rgb_values[0]
                    pixels.extend([pixel_value for _ in range(pixel_weight)])

            # Fetch Median Pixel Value Within Filter And Set New Image Pixel At (y,x) To New Median Value
            if len(pixels) > 1:
                pixels.sort()
                median = pixels[len(pixels)//2] if len(pixels) % 2 == 0 else pixels[len(pixels)//2+1]
                nArray[y][x][0] = median
                nArray[y][x][1] = nArray[y][x][0]
                nArray[y][x][2] = nArray[y][x][0]

    return nArray

#Dilation--Complete   
def Dilation(array, mean_filter = [[1,0,1],[1, 1, 1],[0, 1, 0]] ):
    array = p1.binary(array)
    nArray = array.copy()

    image_width, image_height = array.shape[1],array.shape[0]

    # Compute New Pixel Value
    filter_mid_y = len(mean_filter)//2
    filter_mid_x = len(mean_filter[0])//2

    for y in range(array.shape[0]):
        for x in range(array.shape[1]):
            # Skip Border Pixels
            if x-filter_mid_x < 0 or x+filter_mid_x > image_width : continue
            if y-filter_mid_y < 0 or y+filter_mid_y > image_height: continue

            filter_pixels = array[y-filter_mid_y:y+filter_mid_y+1,x-filter_mid_x:x+filter_mid_x+1]

            # Apply Spatial Filter Over Greyscale Image
            # Only Use First Element (Pixel Value) In Filter Pixel Row, Since
            #   They're All The Same Value (Greyscale Image)
            new_pixel_val, non_zero_count = 0, 0

            for filter_y, rgb_pixel_values in enumerate(filter_pixels):
                for filter_x, rgb_values in enumerate(rgb_pixel_values):
                    pixel_weight = mean_filter[filter_y][filter_x]
                    pixel_value  = rgb_values[0]
                    new_pixel_val += pixel_weight * pixel_value
                    if pixel_weight != 0: non_zero_count += 1
            
            # Compute Average Pixel Value
            new_pixel_val /= non_zero_count

            # Check(s)
            if new_pixel_val < 0  : new_pixel_val = 0
            if new_pixel_val > 255: new_pixel_val = 255

            # Set New Pixel Value
            nArray[y][x][0] = new_pixel_val
            nArray[y][x][1] = nArray[y][x][0]
            nArray[y][x][2] = nArray[y][x][0]

    return nArray

def Edge_Detec1():
    pass

def Edge_Detec2():
    pass


## Segmentation ##

#Balanced--Complete
def balanced(array, minCount = 1800):
    array = p1.LFilter(array)
    histo = p1.histo_one(array)

    numBins = len(histo) 
    hS = 0

    while histo[hS] < minCount:
        hS += 1
    hE = numBins - 1

    while histo[hE] < minCount:
        hE -= 1
    hCount = int(round((hS + hE)/2))
    weightL = np.sum(histo[hS:hCount])   
    weightR = np.sum(histo[hCount:hE +1]) 

    while hS < hE and weightR > 0 and weightL > 0 :
        if weightR < weightL:
            weightL -= histo[hS]
            hS +=1
        else:
            weightR -= histo[hE]
            hE -= 1
        newCount = int(round((hE + hS) / 2))

        if newCount < hCount:
            weightL -= histo[hCount]
            weightR += histo[hCount]
        elif newCount > hCount:
            weightL += histo[hCount]
            weightR -= histo[hCount]
        hCount = newCount
    print(hCount)
    for x in array:
        for n in x:
            if n[0] >= hCount:
                n[0] = 255
                n[1] = 255
                n[2] = 255
            else:
                n[0] = n[0]
                n[1] = n[0]
                n[2] = n[0]
    return array

#Otsu
def Thresh_otsu(array, min = 10000):
    array = p1.LFilter(array)
    histo = p1.histo_one(array)
    tot = array.shape[1] * array.shape[0]
    backW, foreW, sum, threshold = 0,0,0,0
    backSum, backMean, foreMean, varBet, varMax= 0.0, 0.0, 0.0, 0.0, 0.0
    
    for t in range(256):
        sum += t * histo[t]
    
    for t in range(256):
        backW += histo[t]
        if(backW <= min): continue

        foreW = tot - backW

        if(foreW == 0): break

        backMean = backSum/backW
        foreMean = (sum - backSum)/foreW

        varBet = float(backW) + float(foreW) * ((backMean - foreMean)*(backMean - foreMean))

        if(varBet > varMax):
            varMax = varBet
            threshold = t

        if(threshold == 0): threshold = 0     
        else: threshold = threshold

        print(threshold)
        for x in array:
            for n in x:
                if n[0] >= threshold:
                    n[0] = 255
                    n[1] = 255
                    n[2] = 255
                else:
                    n[0] = n[0]
                    n[1] = n[0]
                    n[2] = n[0]
        return array




def clustering(im, k, max):
    pixel_values = im.reshape((-1, 3))
    pixel_values = np.float32(im)
    print(pixel_values.shape)


    k = KMeans(K = k, max_iters = max)
    yPred = k.pred(pixel_values)

    y_pred = y_pred.astype(int)
    np.unique(y_pred)

    labels = yPred.flatten()
    segmented_image = centers[labels.flatten()]
    segmented_image = segmented_image.reshape(image.shape)
    plt.imshow(segmented_image)
    plt.show()





#"/Users/Adhsketch/Desktop/repos/ImageAnalysis/cell_smears/mod01.BMP"
def main():
    directory = "/Users/Adhsketch/Desktop/repos/ImageAnalysis/cell_smears/svar01.BMP"
    im_org = Image.open(directory)

    

    arr = p1.pixel_val_grey(im_org)
    #clustering(arr,3, 100)
    hist = p1.histo_one(arr)

    #arr = balanced(arr)


   # arr = otsu2(arr,hist)
    #arr = p1.histo_equal(arr,hist)
    #hist = p1.histo_one(arr)
    arr = Thresh_otsu(arr)

    #arr = p1.binary(arr,t)
    Image.fromarray(arr).save("NI.BMP")

if __name__ == "__main__":
    main()   